<!DOCTYPE html>
<html>
<head>
    <title>{{ algorithm_name }} - Algorithm Visualizer</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
:root {
    --primary-color: black;
    --primary-dark: black;
    --primary-light: black;
    --secondary-color: #4caf50;
    --text-primary: black;
    --text-secondary: #757575;
    --background-light: #fafafa;
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
    --border-radius: 8px;
}

body {
    font-family: 'Roboto', sans-serif;
    line-height: 1.6;
    color: var(--text-primary);
    background: #f8f9fa;
    margin: 0;
    padding: 20px;
}



.header {
    text-align: center;
    margin-bottom: 10px;
    padding: 18px 10px;
    background: white;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    position: relative;
    border-top: none;
    min-height: 80px;
    max-width: 1200px; /* Match container's max-width */
    margin-left: auto;
    margin-right: auto; /* Center within .container */
}

.back-button {
    text-decoration: none;
    color: var(--primary-color);
    font-weight: 500;
    display: inline-block;
    margin: 0;
    transition: color 0.3s;
    position: absolute;
    top: 10px;
    left: 20px;
    font-size: 0.9em;
    line-height: 1;
}

.back-button:hover {
    color: var(--primary-dark);
}

.header h1 {
    color: var(--text-primary);
    margin: 0 0 5px 0;
    font-size: 2em;
    font-weight: bold;
    line-height: 1.2;
}

.subtitle {
    color: var(--text-secondary);
    margin: 0;
    font-size: 1em;
    font-weight: normal;
    line-height: 1.4;
}

.visualization-container {
    /* max-width: 1200px; Match container's max-width */
    margin: 0 auto; /* Center within viewport */
    width: 1250px; /* Ensure full width within container */
}

.control-panel {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 15px;
    max-width: 1200px; /* Match container's max-width */
    margin-left: auto;
    margin-right: auto; /* Center within .visualization-container */
}

.controls-wrapper {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.input-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-bottom: 15px;
}

.input-group input[type="text"],
.input-group input[type="number"] {
    padding: 8px 12px;
    border: 2px solid #e0e0e0;
    border-radius: 4px;
    font-size: 14px;
    flex: 1;
    min-width: 150px;
    transition: border-color 0.3s;
}

.input-group input[type="text"]:focus,
.input-group input[type="number"]:focus {
    border-color: var(--primary-color);
    outline: none;
}

.input-group button {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s;
    margin-right: 5px;
}

.input-group button:hover {
    background: var(--primary-dark);
}

.primary-button {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s;
}

.primary-button:hover {
    background: var(--primary-dark);
}

.secondary-button {
    background: var(--primary-light);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s, color 0.3s;
}

.secondary-button:hover {
    background: var(--primary-dark);
    color: white;
}

.speed-control {
    display: flex;
    align-items: center;
    gap: 5px;
}

.speed-control label {
    color: var(--text-secondary);
    font-weight: 500;
}

.speed-control input[type="range"] {
    flex: 1;
    max-width: 150px;
}

#speedLabel {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.point-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.canvas-container {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 15px;
    max-width: 1200px; /* Match container's max-width */
    margin-left: auto;
    margin-right: auto; /* Center within .visualization-container */
}

#pointCanvas {
    display: block;
    width: 100%;
    max-width: 600px;
    height: auto;
}

.matrix-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

.matrix-input-container {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.matrix-input {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    flex: 1;
    min-width: 250px;
    max-width: 590px; /* Half of 1200px minus padding and gaps, roughly */
}

.matrix-input h4 {
    color: var(--primary-dark);
    margin: 0 0 10px 0;
    font-size: 1.1em;
}

.matrix-grid {
    display: grid;
    gap: 5px;
}

.matrix-grid input {
    padding: 8px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    font-size: 14px;
    text-align: center;
    width: 100%;
    transition: border-color 0.3s;
}

.matrix-grid input:focus {
    border-color: var(--primary-color);
    outline: none;
}

.visualization-area {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-bottom: 15px;
    min-height: 200px;
    overflow-y: auto;
    max-width: 1200px; /* Match container's max-width */
    margin-left: auto;
    margin-right: auto; /* Center within .visualization-container */
}

#visualizationContainer {
    width: 100%; /* Ensure full width within .visualization-area */
}

.visualization-subcontainer {
    display: none; /* Hidden until visualization starts */
}

.visualization-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 15px;
}

.visualization-controls button {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s;
}

.visualization-controls button:hover {
    background: var(--primary-dark);
}

.step-counter {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.sequence-display {
    display: flex;
    justify-content: center;
    gap: 5px;
    padding: 10px;
    flex-wrap: wrap;
}

.sequence-item {
    width: 40px;
    background: var(--primary-light);
    border-radius: 4px;
    font-weight: bold;
    color: white;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 5px;
    min-height: 35px;
}

.sequence-item.current { /* mid point */
    background: #3498db;
    color: white;
    transform: scale(1.1);
}

.sequence-item.left { /* left boundary */
    background: #f4c7c3;
    color: #c62828;
}

.sequence-item.right { /* right boundary */
    background: #b3e5fc;
    color: #0277bd;
}

.sequence-item.target { /* found target */
    background: #66BB6A;
    color: white;
    transform: scale(1.15);
    box-shadow: var(--shadow-md);
}

.sequence-item.computed {
    background: #e8f5e9;
    color: var(--secondary-color);
}

.array-element.pivot {
    background: #FFCA28;
    color: black;
}

.karatsuba-step, .strassen-step {
    margin-top: 10px;
}

.karatsuba-step .numbers, .strassen-step .matrix {
    margin-bottom: 10px;
}

.karatsuba-step .numbers div, .strassen-step .matrix h4 {
    color: var(--text-primary);
    font-size: 1em;
}

.karatsuba-step .calculation, .strassen-step table {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.strassen-step table {
    border-collapse: collapse;
    margin-top: 5px;
}

.strassen-step td {
    padding: 5px;
    border: 1px solid #e0e0e0;
    text-align: center;
}

.info-panel {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    margin-top: 15px;
    max-width: 1200px; /* Match container's max-width */
    margin-left: auto;
    margin-right: auto; /* Center within .visualization-container */
}

.complexity {
    display: flex;
    flex-direction: row; /* Force side-by-side layout */
    flex-wrap: nowrap; /* Prevent wrapping */
    gap: 10px; /* Reduced gap for tighter fit */
    margin-bottom: 15px;
    padding: 5px; /* Minimal padding to save space */
    background: var(--primary-light);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    width: 100%; /* Ensure full width of parent */
    overflow-x: auto; /* Allow horizontal scrolling if needed */
    justify-content: center; /* Center the items horizontally */
}

.complexity-item {
    flex: 0 0 calc(50% - 10px); /* Fixed width of 50% minus gap, no shrinking/growing */
    text-align: center;
    padding: 8px; /* Reduced padding for tighter fit */
    background: var(--primary-light);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-sm);
    box-sizing: border-box; /* Include padding in width */
    min-width: 150px; /* Minimum width to ensure readability */
}

.complexity-item .label {
    font-weight: bold;
    color: white;
    display: block;
    margin-bottom: 5px;
    font-size: 0.9em;
    text-transform: uppercase;
    white-space: nowrap; /* Prevent text wrapping */
    overflow: hidden; /* Handle overflow */
    text-overflow: ellipsis; /* Add ellipsis for long text */
}

.complexity-item .value {
    font-family: 'Courier New', monospace;
    font-size: 1.1em;
    color: white;
    white-space: nowrap; /* Prevent text wrapping */
    overflow: hidden; /* Handle overflow */
    text-overflow: ellipsis; /* Add ellipsis for long text */
}

.explanation {
    color: var(--text-secondary);
    font-size: 0.9em;
}

.explanation h3 {
    color: var(--primary-dark);
    margin: 0 0 10px 0;
    font-size: 1.3em;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--background-light);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: var(--primary-color);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--primary-dark);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .input-group {
        flex-direction: column;
    }

    .controls-wrapper {
        flex-direction: column;
        align-items: flex-start;
    }

    .complexity {
        gap: 5px; /* Further reduce gap on smaller screens */
        padding: 5px;
    }

    .complexity-item {
        padding: 6px;
        min-width: 120px; /* Slightly smaller minimum width */
        font-size: 0.9em; /* Slightly reduce font size */
    }

    .header, .control-panel, .visualization-area, .info-panel {
        max-width: 100%; /* Allow full width on smaller screens, but capped by .container */
        margin-left: 0;
        margin-right: 0;
    }

    .matrix-input {
        min-width: 100%; /* Full width on mobile */
    }
}

@media (max-width: 480px) {
    body {
        padding: 10px;
    }

    .control-panel, .visualization-area, .info-panel {
        padding: 10px;
    }

    .header h1 {
        font-size: 1.5em;
    }

    .subtitle {
        font-size: 0.9em;
    }

    .back-button {
        position: static;
        text-align: left;
        margin-bottom: 5px;
    }

    .complexity {
        gap: 5px;
        padding: 5px;
    }

    .complexity-item {
        padding: 4px;
        min-width: 100px; /* Even smaller minimum width */
        font-size: 0.8em; /* Further reduce font size */
    }
}

@media (max-width: 320px) {
    /* Optional: Allow stacking only on extremely small screens */
    .complexity {
        flex-direction: column;
        flex-wrap: wrap;
        gap: 5px;
    }

    .complexity-item {
        flex: 0 0 100%;
        min-width: 100%;
        padding: 4px;
    }
}
    </style>
</head>
<body>
    <div class="container">
    <div class="header">
        <a href="/" class="back-button">← Back to Algorithms</a>
        <h1>{{ algorithm_name }}</h1>
        <p class="subtitle">{{ algorithm_description }}</p>
    </div>

    <div class="visualization-container">
        <div class="control-panel">
            <div class="controls-wrapper">
                <div class="input-group">
                    {% if algorithm_id == 'divide-conquer/binary-search' %}
                        <input type="text" id="array" placeholder="Sorted array (e.g., 1,3,5,7,9)">
                        <input type="number" id="target" placeholder="Target value">
                        <button onclick="generateRandomArray('sorted')">Random Sorted Array</button>
                    {% elif algorithm_id == 'divide-conquer/merge-sort' %}
                        <input type="text" id="array" placeholder="Array to sort (e.g., 5,2,8,1,9)">
                        <button onclick="generateRandomArray('unsorted')">Random Array</button>
                    {% elif algorithm_id == 'divide-conquer/quick-sort' %}
                        <input type="text" id="array" placeholder="Array to sort (e.g., 5,2,8,1,9)">
                        <button onclick="generateRandomArray('unsorted')">Random Array</button>
                    {% elif algorithm_id == 'divide-conquer/closest-pair' %}
                        <div class="point-controls">
                            <button onclick="addPoint()">Add Point</button>
                            <button onclick="generateRandomPoints()">Random Points</button>
                            <button onclick="clearPoints()">Clear Points</button>
                        </div>
                        <div class="canvas-container">
                            <canvas id="pointCanvas" width="600" height="400"></canvas>
                        </div>
                    {% elif algorithm_id == 'divide-conquer/karatsuba' %}
                        <input type="number" id="num1" placeholder="First number (e.g., 1234)">
                        <input type="number" id="num2" placeholder="Second number (e.g., 5678)">
                        <button onclick="generateRandomNumbers()">Random Numbers</button>
                    {% elif algorithm_id == 'divide-conquer/strassen' %}
                        <div class="matrix-controls">
                            <button onclick="setMatrixSize()">Set Matrix Size</button>
                            <button onclick="generateRandomMatrices()">Random Matrices</button>
                            <button onclick="clearMatrices()">Clear Matrices</button>
                        </div>
                        <div class="matrix-input-container">
                            <div class="matrix-input" id="matrixA">
                                <h4>Matrix A</h4>
                                <div class="matrix-grid"></div>
                            </div>
                            <div class="matrix-input" id="matrixB">
                                <h4>Matrix B</h4>
                                <div class="matrix-grid"></div>
                            </div>
                        </div>
                    {% endif %}
                    <button onclick="visualize('{{ algorithm_id }}')" class="primary-button">Visualize</button>
                    <button onclick="resetVisualization()" class="secondary-button">Reset</button>
                </div>
                <div class="speed-control">
                    <label for="speed">Animation Speed:</label>
                    <input type="range" id="speed" min="1" max="5" value="3">
                    <span id="speedLabel">Normal</span>
                </div>
            </div>
        </div>

        <div class="visualization-area">
            <div id="visualizationContainer">
                <div class="visualization-subcontainer">
                    <div class="visualization-controls">
                        <button id="prevButton" onclick="navigateStep(-1)">← Previous</button>
                        <button id="playButton" onclick="toggleAnimation(this)">Play</button>
                        <button id="nextButton" onclick="navigateStep(1)">Next →</button>
                        <div class="step-counter" id="stepCounter">Step 0 of 0</div>
                    </div>
                    <div id="stepDisplay"></div>
                    <div id="explanationDisplay" class="step-explanation"></div>
                </div>
            </div>
            <div class="info-panel">
                <div class="complexity">
                    <div class="complexity-item">
                        <span class="label">Time Complexity:</span>
                        <span class="value">{{ time_complexity }}</span>
                    </div>
                    <div class="complexity-item">
                        <span class="label">Space Complexity:</span>
                        <span class="value">{{ space_complexity }}</span>
                    </div>
                </div>
                <div class="explanation">
                    <h3>How it works</h3>
                    <p>{{ algorithm_explanation }}</p>
                    {% if algorithm_id == 'divide-conquer/binary-search' %}
                        <p>How it works: Repeatedly halves the search range to find the target in a sorted array.</p>
                    {% elif algorithm_id == 'divide-conquer/merge-sort' %}
                        <p>How it works: Divides the array into halves, sorts them, and merges them back together.</p>
                    {% elif algorithm_id == 'divide-conquer/quick-sort' %}
                        <p>How it works: Partitions the array around a pivot and recursively sorts the subarrays.</p>
                    {% elif algorithm_id == 'divide-conquer/closest-pair' %}
                        <p>How it works: Divides points by x-coordinate and finds the closest pair efficiently.</p>
                    {% elif algorithm_id == 'divide-conquer/karatsuba' %}
                        <p>How it works: Splits numbers into parts and uses three multiplications to compute the product.</p>
                    {% elif algorithm_id == 'divide-conquer/strassen' %}
                        <p>How it works: Divides matrices into quadrants and uses seven multiplications for efficiency.</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>
    <script>
       class VisualizationState {
    constructor() {
        this.currentStep = 0;
        this.steps = [];
        this.animationInterval = null;
        this.isVisualizing = false;
        this.algorithmId = '{{ algorithm_id }}';
        this.target = null;  // Add target property
    }

    reset() {
        if (this.animationInterval) {
            clearInterval(this.animationInterval);
            this.animationInterval = null;
        }
        this.currentStep = 0;
        this.steps = [];
        this.isVisualizing = false;
        // Don't reset target here so it persists
    }
}

        const state = new VisualizationState();
        const speedControl = document.getElementById('speed');
        const speedLabel = document.getElementById('speedLabel');
        let points = [];
        let matrixA = [];
        let matrixB = [];
        let matrixSize = 4;
        let isDrawing = false;
        
        speedControl.addEventListener('input', function() {
            const speeds = ['Very Slow', 'Slow', 'Normal', 'Fast', 'Very Fast'];
            speedLabel.textContent = speeds[this.value - 1];
        });
        
        function getDelay() {
            const delays = [1000, 800, 600, 400, 200];
            return delays[speedControl.value - 1];
        }

        const canvas = document.getElementById('pointCanvas');
        if (canvas) {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
        }

        function startDrawing(e) {
            isDrawing = true;
            addPointAtEvent(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            addPointAtEvent(e);
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function addPointAtEvent(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            points.push([x, y]);
            drawPoints();
        }
        
        function generateRandomArray(type) {
            const size = Math.floor(Math.random() * 8) + 5;
            let arr = Array.from({length: size}, () => Math.floor(Math.random() * 100));
            if (type === 'sorted') {
                arr.sort((a, b) => a - b);
            }
            document.getElementById('array').value = arr.join(',');
        }

        function generateRandomPoints() {
            points = [];
            const numPoints = Math.floor(Math.random() * 6) + 5;
            for (let i = 0; i < numPoints; i++) {
                points.push([
                    Math.floor(Math.random() * (canvas.width - 40) + 20),
                    Math.floor(Math.random() * (canvas.height - 40) + 20)
                ]);
            }
            drawPoints();
        }

        function addPoint() {
            const x = Math.floor(Math.random() * (canvas.width - 40) + 20);
            const y = Math.floor(Math.random() * (canvas.height - 40) + 20);
            points.push([x, y]);
            drawPoints();
        }

        function drawPoints() {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            points.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point[0], point[1], 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                ctx.strokeStyle = '#2E7D32';
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`P${index + 1}`, point[0], point[1] - 8);
            });
        }
        
        function clearPoints() {
            points = [];
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        async function visualize(algorithmId) {
    if (state.isVisualizing) return;
    state.isVisualizing = true;
    state.reset();

    const container = document.getElementById('visualizationContainer');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading';
    loadingDiv.textContent = 'Loading visualization...';
    container.innerHTML = '';
    container.appendChild(loadingDiv);

    const data = {};
    try {
        if (algorithmId === 'divide-conquer/binary-search') {
            const arrayInput = document.getElementById('array').value;
            const targetInput = document.getElementById('target').value;
            if (!arrayInput || !targetInput) throw new Error('Please provide both array and target value');
            data.array = arrayInput.split(',').map(Number);
            data.target = parseInt(targetInput);
            state.target = data.target;
            console.log('Input data:', data); // Debug input
        } else if (algorithmId === 'divide-conquer/merge-sort' || algorithmId === 'divide-conquer/quick-sort') {
            const arrayInput = document.getElementById('array').value;
            if (!arrayInput) throw new Error('Please provide an array to sort');
            data.array = arrayInput.split(',').map(Number);
        } else if (algorithmId === 'divide-conquer/closest-pair') {
            if (points.length < 2) throw new Error('Please add at least 2 points');
            data.points = points;
        } else if (algorithmId === 'divide-conquer/karatsuba') {
            const num1Input = document.getElementById('num1').value;
            const num2Input = document.getElementById('num2').value;
            if (!num1Input || !num2Input) throw new Error('Please provide both numbers');
            data.x = parseInt(num1Input);
            data.y = parseInt(num2Input);
        } else if (algorithmId === 'divide-conquer/strassen') {
            data.matrix_a = matrixA;
            data.matrix_b = matrixB;
        }

        const response = await fetch(`/api/${algorithmId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        if (!response.ok) throw new Error('Visualization failed');

        const { steps } = await response.json();
        console.log('Received steps:', steps); // Debug API response
        if (!steps || !Array.isArray(steps)) throw new Error('Invalid steps data received');
        
        // Validate binary search steps
        if (algorithmId === 'divide-conquer/binary-search') {
            steps.forEach((step, index) => {
                if (!step.array || step.left === undefined || step.right === undefined || step.mid === undefined) {
                    console.warn(`Invalid step data at index ${index}:`, step);
                }
            });
        }
        
        state.steps = steps;
        setupVisualization(container);
        showStep();
    } catch (error) {
        console.error('Error:', error);
        container.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
    } finally {
        state.isVisualizing = false;
    }
}
        function setupVisualization(container) {
            container.innerHTML = `
                <div class="visualization-subcontainer">
                    <div class="visualization-controls">
                        <button id="prevButton" onclick="navigateStep(-1)">← Previous</button>
                        <button id="playButton" onclick="toggleAnimation(this)">Play</button>
                        <button id="nextButton" onclick="navigateStep(1)">Next →</button>
                        <div class="step-counter" id="stepCounter">Step 0 of ${state.steps.length}</div>
                    </div>
                    <div id="stepDisplay"></div>
                    <div id="explanationDisplay" class="step-explanation"></div>
                </div>
            `;
            document.querySelector('.visualization-subcontainer').style.display = 'block';
        }

        function navigateStep(delta) {
            const newStep = state.currentStep + delta;
            if (newStep >= 0 && newStep < state.steps.length) {
                state.currentStep = newStep;
                showStep();
            }
        }

        function toggleAnimation(playButton) {
            if (state.animationInterval) {
                clearInterval(state.animationInterval);
                state.animationInterval = null;
                playButton.textContent = 'Play';
            } else {
                playButton.textContent = 'Pause';
                state.animationInterval = setInterval(() => {
                    if (state.currentStep < state.steps.length - 1) {
                        state.currentStep++;
                        showStep();
                    } else {
                        clearInterval(state.animationInterval);
                        state.animationInterval = null;
                        playButton.textContent = 'Play';
                    }
                }, getDelay());
            }
        }

       // Update showStep with better handling of undefined values
function showStep() {
    const step = state.steps[state.currentStep];
    const stepDisplay = document.getElementById('stepDisplay');
    const explanationDisplay = document.getElementById('explanationDisplay');
    const stepCounter = document.getElementById('stepCounter');

    stepCounter.textContent = `Step ${state.currentStep + 1} of ${state.steps.length}`;
    stepDisplay.innerHTML = '';

    if (state.currentStep === state.steps.length - 1 && state.algorithmId === 'divide-conquer/binary-search') {
        const targetIndex = step.target_index !== undefined ? step.target_index : 'unknown';
        explanationDisplay.textContent = targetIndex === -1 
            ? "Target not found in the array"
            : `Target ${state.target || 'unknown'} found at index ${targetIndex}`;
    } else {
        explanationDisplay.textContent = step.explanation || 'Processing step...';
    }

    const displayFunctions = {
        'divide-conquer/binary-search': displayBinarySearch,
        'divide-conquer/merge-sort': displaySorting,
        'divide-conquer/quick-sort': displaySorting,
        'divide-conquer/closest-pair': displayClosestPair,
        'divide-conquer/karatsuba': displayKaratsuba,
        'divide-conquer/strassen': displayStrassen
    };

    const displayFunc = displayFunctions[state.algorithmId] || (() => {
        stepDisplay.innerHTML = '<div class="error-message">Visualization not implemented</div>';
    });
    displayFunc(step, stepDisplay);
}

// Update displayBinarySearch with validation and fallbacks
function displayBinarySearch(step, container) {
    const arrayContainer = document.createElement('div');
    arrayContainer.className = 'sequence-display';
    
    const targetValue = state.target !== null ? state.target : (step.target !== undefined ? step.target : 'Unknown');
    const targetDisplay = document.createElement('div');
    targetDisplay.style.marginBottom = '10px';
    targetDisplay.style.fontSize = '1.1em';
    targetDisplay.textContent = `Searching for: ${targetValue}`;
    container.appendChild(targetDisplay);

    // Validate step data
    const left = step.left !== undefined ? step.left : 0;
    const right = step.right !== undefined ? step.right : (step.array ? step.array.length - 1 : 0);
    const mid = step.mid !== undefined ? step.mid : Math.floor((left + right) / 2);
    const targetIndex = step.target_index !== undefined ? step.target_index : -1;

    if (!step.array || !Array.isArray(step.array)) {
        container.innerHTML = '<div class="error-message">Invalid array data</div>';
        console.error('Invalid array in step:', step);
        return;
    }

    step.array.forEach((num, index) => {
        const element = document.createElement('div');
        element.className = 'sequence-item';
        element.textContent = num;
        
        if (targetIndex !== -1 && index === targetIndex) {
            element.classList.add('target');
        }
        if (index === mid) {
            element.classList.add('current');
        }
        if (index === left) {
            element.classList.add('left');
        }
        if (index === right) {
            element.classList.add('right');
        }
        if (index < left || index > right) {
            element.style.opacity = '0.3';
        }
        
        arrayContainer.appendChild(element);
    });
    
    container.appendChild(arrayContainer);

    const stepInfo = document.createElement('div');
    stepInfo.style.marginTop = '10px';
    stepInfo.style.color = 'var(--text-secondary)';
    
    if (targetIndex !== undefined) {
        stepInfo.textContent = targetIndex === -1 
            ? 'Target not found in array'
            : `Target found at index ${targetIndex}`;
    } else {
        stepInfo.textContent = `Checking range [${left}, ${right}], mid: ${mid}`;
    }
    
    container.appendChild(stepInfo);
}
        function displaySorting(step, container) {
            const arrayContainer = document.createElement('div');
            arrayContainer.className = 'sequence-display';
            step.array.forEach((num, index) => {
                const element = document.createElement('div');
                element.className = 'sequence-item';
                element.textContent = num;
                if (step.comparing && step.comparing.includes(index)) {
                    element.classList.add('current');
                } else if (step.sorted && step.sorted.includes(index)) {
                    element.classList.add('computed');
                } else if (step.pivot_index === index) {
                    element.classList.add('pivot');
                }
                arrayContainer.appendChild(element);
            });
            container.appendChild(arrayContainer);
        }

        function displayClosestPair(step, container) {
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            step.points.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point[0], point[1], 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#4CAF50';
                ctx.fill();
                ctx.strokeStyle = '#2E7D32';
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`P${index + 1}`, point[0], point[1] - 8);
            });
            
            if (step.comparing) {
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(step.comparing[0][0], step.comparing[0][1]);
                ctx.lineTo(step.comparing[1][0], step.comparing[1][1]);
                ctx.stroke();
                
                step.comparing.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 7, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#FF5722';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                if (step.distance) {
                    ctx.fillStyle = '#000';
                    ctx.font = '14px Arial';
                    const midX = (step.comparing[0][0] + step.comparing[1][0]) / 2;
                    const midY = (step.comparing[0][1] + step.comparing[1][1]) / 2;
                    ctx.fillText(`Distance: ${step.distance.toFixed(2)}`, midX, midY - 10);
                }
            }
            
            if (step.divide_x !== undefined) {
                ctx.beginPath();
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(step.divide_x, 0);
                ctx.lineTo(step.divide_x, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (step.strip_x !== undefined && step.strip_width !== undefined) {
                ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
                ctx.fillRect(
                    step.strip_x - step.strip_width / 2,
                    0,
                    step.strip_width,
                    canvas.height
                );
            }
            
            container.appendChild(canvas);
        }

        function displayKaratsuba(step, container) {
            const karatsubaDiv = document.createElement('div');
            karatsubaDiv.className = 'karatsuba-step';
            if (step.numbers) {
                const numbersDiv = document.createElement('div');
                numbersDiv.className = 'numbers';
                numbersDiv.innerHTML = `
                    <div>X = ${step.numbers.x}</div>
                    <div>Y = ${step.numbers.y}</div>
                `;
                karatsubaDiv.appendChild(numbersDiv);
            }
            if (step.calculation) {
                const calcDiv = document.createElement('div');
                calcDiv.className = 'calculation';
                calcDiv.innerHTML = step.calculation;
                karatsubaDiv.appendChild(calcDiv);
            }
            container.appendChild(karatsubaDiv);
        }

        function displayStrassen(step, container) {
            const strassenDiv = document.createElement('div');
            strassenDiv.className = 'strassen-step';
            ['A', 'B', 'Result'].forEach(matrixName => {
                if (step[matrixName.toLowerCase()]) {
                    const matrixDiv = document.createElement('div');
                    matrixDiv.className = 'matrix';
                    matrixDiv.innerHTML = `<h4>Matrix ${matrixName}</h4>`;
                    const table = document.createElement('table');
                    step[matrixName.toLowerCase()].forEach(row => {
                        const tr = document.createElement('tr');
                        row.forEach(cell => {
                            const td = document.createElement('td');
                            td.textContent = cell;
                            tr.appendChild(td);
                        });
                        table.appendChild(tr);
                    });
                    matrixDiv.appendChild(table);
                    strassenDiv.appendChild(matrixDiv);
                }
            });
            container.appendChild(strassenDiv);
        }

        function resetVisualization() {
            state.reset();
            const container = document.getElementById('visualizationContainer');
            container.innerHTML = `
                <div class="visualization-subcontainer">
                    <div class="visualization-controls">
                        <button id="prevButton" onclick="navigateStep(-1)">← Previous</button>
                        <button id="playButton" onclick="toggleAnimation(this)">Play</button>
                        <button id="nextButton" onclick="navigateStep(1)">Next →</button>
                        <div class="step-counter" id="stepCounter">Step 0 of 0</div>
                    </div>
                    <div id="stepDisplay"></div>
                    <div id="explanationDisplay" class="step-explanation"></div>
                </div>
            `;
            document.querySelector('.visualization-subcontainer').style.display = 'none';
            if (state.algorithmId === 'divide-conquer/closest-pair') {
                clearPoints();
            } else if (state.algorithmId === 'divide-conquer/strassen') {
                clearMatrices();
            }
        }

        function generateRandomNumbers() {
            const maxDigits = 4;
            document.getElementById('num1').value = Math.floor(Math.random() * Math.pow(10, maxDigits));
            document.getElementById('num2').value = Math.floor(Math.random() * Math.pow(10, maxDigits));
        }

        function setMatrixSize() {
            const size = prompt('Enter matrix size (must be a power of 2):', '4');
            if (size) {
                const n = parseInt(size);
                if (n && (n & (n - 1)) === 0) {
                    matrixSize = n;
                    clearMatrices();
                    initializeMatrices();
                } else {
                    alert('Matrix size must be a power of 2');
                }
            }
        }

        function generateRandomMatrices() {
            matrixA = Array(matrixSize).fill().map(() => 
                Array(matrixSize).fill().map(() => Math.floor(Math.random() * 10))
            );
            matrixB = Array(matrixSize).fill().map(() => 
                Array(matrixSize).fill().map(() => Math.floor(Math.random() * 10))
            );
            displayMatrices();
        }

        function clearMatrices() {
            matrixA = Array(matrixSize).fill().map(() => Array(matrixSize).fill(0));
            matrixB = Array(matrixSize).fill().map(() => Array(matrixSize).fill(0));
            displayMatrices();
        }

        function initializeMatrices() {
            const matrixADiv = document.querySelector('#matrixA .matrix-grid');
            const matrixBDiv = document.querySelector('#matrixB .matrix-grid');
            [matrixADiv, matrixBDiv].forEach((div, matrixIndex) => {
                div.innerHTML = '';
                div.style.gridTemplate = `repeat(${matrixSize}, 1fr) / repeat(${matrixSize}, 1fr)`;
                for (let i = 0; i < matrixSize; i++) {
                    for (let j = 0; j < matrixSize; j++) {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.value = 0;
                        input.dataset.row = i;
                        input.dataset.col = j;
                        input.addEventListener('change', (e) => {
                            const matrix = matrixIndex === 0 ? matrixA : matrixB;
                            matrix[i][j] = parseInt(e.target.value) || 0;
                        });
                        div.appendChild(input);
                    }
                }
            });
        }

        function displayMatrices() {
            const matrixAInputs = document.querySelectorAll('#matrixA .matrix-grid input');
            const matrixBInputs = document.querySelectorAll('#matrixB .matrix-grid input');
            matrixAInputs.forEach(input => {
                const i = parseInt(input.dataset.row);
                const j = parseInt(input.dataset.col);
                input.value = matrixA[i][j];
            });
            matrixBInputs.forEach(input => {
                const i = parseInt(input.dataset.row);
                const j = parseInt(input.dataset.col);
                input.value = matrixB[i][j];
            });
        }
    </script>
</body>
</html>