<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Graph Algorithm Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f6fa;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 2.2rem;
            font-weight: 600;
        }

        .subtitle {
            color: #bdc3c7;
            margin: 0.5rem 0;
        }

        .back-button {
            position: absolute;
            left: 2rem;
            top: 1.5rem;
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .back-button:hover {
            background: rgba(255,255,255,0.1);
        }

        .container {
            display: flex;
            padding: 1rem;
            gap: 1rem;
            height: calc(100vh - 120px);
        }

        .controls {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s;
            background: #f8f9fa;
            color: #2c3e50;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .algorithm-controls {
            background: white;
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 1rem;
        }

        .algorithm-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 1rem;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        input[type="range"] {
            flex: 1;
            height: 5px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }

        .graph-area {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            flex: 1;
            overflow: hidden;
        }

        .step-panel {
            width: 300px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            padding: 1rem;
            overflow-y: auto;
        }

        .step-item {
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 5px;
            margin-bottom: 0.5rem;
            transition: all 0.3s;
        }

        .step-item.active {
            border-color: #3498db;
            background: #f8f9fa;
        }

        .step-number {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .step-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            width: 400px;
            max-width: 90%;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .input-group input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .generator-controls {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
        }

        .number-input {
            width: 80px;
            padding: 0.3rem;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .range-input {
            width: 100%;
        }

        .algorithm-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            margin-bottom: 1rem;
        }

        .stats-panel {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            pointer-events: none;
        }

        .path-highlight {
            stroke: #2ecc71 !important;
            stroke-width: 3px !important;
        }

        /* Node and Edge Styles */
        .node circle {
            transition: all 0.3s;
        }

        .edge line {
            transition: all 0.3s;
        }

        .node-distance-label {
            font-family: monospace;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .step-panel {
                width: 100%;
                height: 300px;
            }

            .controls {
                flex-wrap: wrap;
            }

            .btn {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/" class="back-button">‚Üê Back to Algorithms</a>
        <h1>Graph Algorithm Visualizer</h1>
        <p class="subtitle">Visualize and understand how graph algorithms work step by step</p>
    </div>
    <div class="container">
        <div>
            <div class="controls">
                <button class="btn" onclick="addNode()" title="Ctrl+N">
                    <span>‚ûï</span> Add Node
                </button>
                <button class="btn" onclick="connectNodes()" title="Ctrl+C">
                    <span>üîó</span> Connect Nodes
                </button>
                <button class="btn btn-success" onclick="runAlgorithm()" title="Ctrl+Space">
                    <span>‚ñ∂Ô∏è</span> Run Algorithm
                </button>
                <button class="btn btn-danger" onclick="resetGraph()" title="Ctrl+R">
                    <span>üîÑ</span> Reset
                </button>
                <button class="btn btn-primary" onclick="generateRandomGraph()" title="Ctrl+G">
                    <span>üé≤</span> Generate Random
                </button>
            </div>
            <div class="algorithm-controls">
                <select id="algorithmSelect" class="algorithm-select">
                    <option value="bfs">Breadth-First Search (BFS)</option>
                    <option value="dfs">Depth-First Search (DFS)</option>
                    <option value="dijkstra">Dijkstra's Algorithm</option>
                    <option value="prim">Prim's MST Algorithm</option>
                    <option value="kruskal">Kruskal's MST Algorithm</option>
                </select>
                <div class="speed-control">
                    <label for="speedControl">Speed:</label>
                    <input type="range" id="speedControl" min="1" max="5" value="3">
                </div>
                <div id="speedLabel">Normal</div>
                <div class="generator-controls">
                    <div class="input-group">
                        <label for="nodeCount">Nodes:</label>
                        <input type="number" id="nodeCount" min="2" max="15" value="5" class="number-input">
                    </div>
                    <div class="input-group">
                        <label for="density">Density:</label>
                        <input type="range" id="density" min="1" max="100" value="50" class="range-input">
                        <span id="densityValue">50%</span>
                    </div>
                    <div class="input-group">
                        <label for="maxWeight">Max Weight:</label>
                        <input type="number" id="maxWeight" min="1" max="100" value="10" class="number-input">
                    </div>
                </div>
            </div>
            <div id="graphContainer" class="graph-area"></div>
        </div>
        <div class="step-panel" id="stepPanel">
            <h3>Algorithm Steps</h3>
            <div id="stepList"></div>
        </div>
    </div>

    <div id="nodeModal" class="modal">
        <div class="modal-content">
            <h3>Connect Nodes</h3>
            <div class="input-group">
                <label for="sourceNode">Source Node</label>
                <input type="number" id="sourceNode" placeholder="Enter source node number">
            </div>
            <div class="input-group">
                <label for="targetNode">Target Node</label>
                <input type="number" id="targetNode" placeholder="Enter target node number">
            </div>
            <div class="input-group">
                <label for="edgeWeight">Edge Weight</label>
                <input type="number" id="edgeWeight" placeholder="Enter edge weight (default: 1)">
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="confirmNodeConnection()">Confirm</button>
                <button class="btn btn-danger" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        class DisjointSet {
            constructor(size) {
                this.parent = new Array(size).fill(-1);
            }

            find(x) {
                if (this.parent[x] < 0) return x;
                return this.parent[x] = this.find(this.parent[x]);
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX !== rootY) {
                    if (this.parent[rootX] < this.parent[rootY]) {
                        this.parent[rootX] += this.parent[rootY];
                        this.parent[rootY] = rootX;
                    } else {
                        this.parent[rootY] += this.parent[rootX];
                        this.parent[rootX] = rootY;
                    }
                }
            }

            connected(x, y) {
                return this.find(x) === this.find(y);
            }
        }

        class GraphVisualizer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
                this.nodes = [];
                this.edges = [];
                this.svg = null;
                this.simulation = null;
                this.tooltip = null;
                this.draggedNode = null;
                this.selectedNode = null;
                this.currentSteps = [];
                this.initializeSVG();
                this.initializeTooltip();
                this.setupZoom();
            }

            initializeSVG() {
                this.svg = d3.select(this.container)
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .style('background', 'white');

                const defs = this.svg.append('defs');
                defs.append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '-5 -5 10 10')
                    .attr('refX', 20)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .append('path')
                    .attr('d', 'M-5,-5 L5,0 L-5,5')
                    .attr('fill', '#95a5a6');

                this.simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id).distance(150))
                    .force('charge', d3.forceManyBody().strength(-800))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide().radius(50))
                    .force('x', d3.forceX(this.width / 2).strength(0.1))
                    .force('y', d3.forceY(this.height / 2).strength(0.1));
            }

            initializeTooltip() {
                this.tooltip = d3.select('body')
                    .append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0);
            }

            setupZoom() {
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 2])
                    .on('zoom', (event) => {
                        this.svg.selectAll('g').attr('transform', event.transform);
                    });
                this.svg.call(zoom);
            }

            addNode() {
                const padding = 100;
                const width = this.width - 2 * padding;
                const height = this.height - 2 * padding;
                
                let x, y, tooClose;
                do {
                    x = padding + Math.random() * width;
                    y = padding + Math.random() * height;
                    tooClose = this.nodes.some(node => {
                        const dx = node.x - x;
                        const dy = node.y - y;
                        return Math.sqrt(dx * dx + dy * dy) < 100;
                    });
                } while (tooClose && this.nodes.length > 0);

                const newNode = { id: this.nodes.length, x, y };
                this.nodes.push(newNode);
                this.updateGraph();
                return newNode.id;
            }

            addEdge(source, target, weight = 1) {
                const sourceNode = this.nodes.find(n => n.id === parseInt(source));
                const targetNode = this.nodes.find(n => n.id === parseInt(target));
                
                if (!sourceNode || !targetNode) throw new Error('Invalid node IDs');
                if (source === target) throw new Error('Self-loops are not allowed');
                
                const edgeExists = this.edges.some(e => 
                    (e.source.id === source && e.target.id === target) ||
                    (e.source.id === target && e.target.id === source)
                );
                
                if (edgeExists) throw new Error('Edge already exists');
                
                this.edges.push({
                    source: sourceNode,
                    target: targetNode,
                    weight: parseInt(weight)
                });
                
                this.updateGraph();
                this.simulation.alpha(0.3).restart();
            }

            updateGraph() {
                const edges = this.svg.selectAll('.edge')
                    .data(this.edges)
                    .join('g')
                    .attr('class', 'edge');

                edges.selectAll('line').remove();
                edges.append('line')
                    .attr('stroke', '#95a5a6')
                    .attr('stroke-width', 2.5)
                    .attr('marker-end', 'url(#arrowhead)')
                    .attr('opacity', 0.8)
                    .on('mouseover', function() {
                        d3.select(this)
                            .attr('opacity', 1)
                            .attr('stroke-width', 3);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('opacity', 0.8)
                            .attr('stroke-width', 2.5);
                    });

                edges.selectAll('text').remove();
                edges.append('text')
                    .attr('class', 'edge-weight')
                    .text(d => d.weight)
                    .attr('dy', -5);

                const nodes = this.svg.selectAll('.node')
                    .data(this.nodes)
                    .join('g')
                    .attr('class', 'node')
                    .call(this.drag());

                nodes.selectAll('circle').remove();
                nodes.append('circle')
                    .attr('r', 25)
                    .attr('fill', '#3498db')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 3)
                    .attr('cursor', 'pointer')
                    .on('mouseover', function() {
                        d3.select(this)
                            .attr('r', 27)
                            .attr('stroke-width', 4);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('r', 25)
                            .attr('stroke-width', 3);
                    });

                nodes.selectAll('text').remove();
                nodes.append('text')
                    .text(d => d.id)
                    .attr('font-size', '14px')
                    .attr('font-weight', 'bold')
                    .attr('fill', 'white')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.3em');

                this.simulation
                    .nodes(this.nodes)
                    .force('link').links(this.edges);

                this.simulation.on('tick', () => {
                    this.nodes.forEach(node => {
                        node.x = Math.max(50, Math.min(this.width - 50, node.x));
                        node.y = Math.max(50, Math.min(this.height - 50, node.y));
                    });

                    edges.selectAll('line')
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    edges.selectAll('text')
                        .attr('x', d => (d.source.x + d.target.x) / 2)
                        .attr('y', d => (d.source.y + d.target.y) / 2);

                    nodes.attr('transform', d => `translate(${d.x},${d.y})`);
                });

                this.simulation.alpha(1).restart();
            }

            drag() {
                return d3.drag()
                    .on('start', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                        this.draggedNode = d;
                        this.showNodeTooltip(d);
                    })
                    .on('drag', (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                        this.updateTooltipPosition(event);
                    })
                    .on('end', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                        this.draggedNode = null;
                        this.hideTooltip();
                    });
            }

            showNodeTooltip(node) {
                this.tooltip
                    .style('opacity', 1)
                    .html(`Node ${node.id}`);
            }

            updateTooltipPosition(event) {
                this.tooltip
                    .style('left', (event.sourceEvent.pageX + 10) + 'px')
                    .style('top', (event.sourceEvent.pageY - 10) + 'px');
            }

            hideTooltip() {
                this.tooltip.style('opacity', 0);
            }

            resetGraph() {
                this.nodes = [];
                this.edges = [];
                this.currentSteps = [];
                this.svg.selectAll('*').remove();
                this.initializeSVG();
                this.updateGraph();
                
                const stepList = document.getElementById('stepList');
                if (stepList) stepList.innerHTML = '';
                
                const algorithmInfo = document.querySelector('.algorithm-info');
                if (algorithmInfo) algorithmInfo.remove();
                const statsPanel = document.querySelector('.stats-panel');
                if (statsPanel) statsPanel.remove();
            }

            async bfs(startNode = 0) {
                const visited = new Set();
                const queue = [startNode];
                const steps = [];

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current)) continue;

                    visited.add(current);
                    steps.push({
                        type: 'visit',
                        node: current,
                        visited: Array.from(visited)
                    });

                    const neighbors = this.edges
                        .filter(e => e.source.id === current)
                        .map(e => e.target.id);

                    for (const neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            queue.push(neighbor);
                            steps.push({
                                type: 'discover',
                                node: neighbor,
                                from: current
                            });
                        }
                    }
                }
                return steps;
            }

            async dfs(startNode = 0) {
                const visited = new Set();
                const steps = [];

                const dfsRecursive = (node) => {
                    visited.add(node);
                    steps.push({
                        type: 'visit',
                        node: node,
                        visited: Array.from(visited)
                    });

                    const neighbors = this.edges
                        .filter(e => e.source.id === node)
                        .map(e => e.target.id);

                    for (const neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            steps.push({
                                type: 'discover',
                                node: neighbor,
                                from: node
                            });
                            dfsRecursive(neighbor);
                        }
                    }
                };

                dfsRecursive(startNode);
                return steps;
            }

            async dijkstra(startNode = 0) {
                const distances = {};
                const previous = {};
                const unvisited = new Set();
                const steps = [];

                this.nodes.forEach(node => {
                    distances[node.id] = Infinity;
                    unvisited.add(node.id);
                });
                distances[startNode] = 0;

                while (unvisited.size > 0) {
                    let current = Array.from(unvisited)
                        .reduce((min, node) => 
                            distances[node] < distances[min] ? node : min
                        );

                    unvisited.delete(current);
                    steps.push({
                        type: 'visit',
                        node: current,
                        distances: {...distances},
                        previous: {...previous}
                    });

                    const neighbors = this.edges
                        .filter(e => e.source.id === current)
                        .map(e => ({
                            node: e.target.id,
                            weight: e.weight
                        }));

                    for (const {node: neighbor, weight} of neighbors) {
                        if (!unvisited.has(neighbor)) continue;

                        const newDistance = distances[current] + weight;
                        if (newDistance < distances[neighbor]) {
                            distances[neighbor] = newDistance;
                            previous[neighbor] = current;
                            steps.push({
                                type: 'update',
                                node: neighbor,
                                from: current,
                                distance: newDistance,
                                distances: {...distances},
                                previous: {...previous}
                            });
                        }
                    }
                }
                return steps;
            }

            async prim(startNode = 0) {
                const visited = new Set();
                const mst = [];
                const steps = [];
                
                visited.add(startNode);
                steps.push({
                    type: 'visit',
                    node: startNode,
                    visited: Array.from(visited)
                });

                while (visited.size < this.nodes.length) {
                    let minEdge = null;
                    let minWeight = Infinity;
                    
                    for (const edge of this.edges) {
                        const sourceVisited = visited.has(edge.source.id);
                        const targetVisited = visited.has(edge.target.id);
                        
                        if (sourceVisited !== targetVisited && edge.weight < minWeight) {
                            minEdge = edge;
                            minWeight = edge.weight;
                        }
                    }
                    
                    if (!minEdge) break;
                    
                    const newNode = visited.has(minEdge.source.id) ? minEdge.target.id : minEdge.source.id;
                    visited.add(newNode);
                    mst.push(minEdge);
                    
                    steps.push({
                        type: 'edge',
                        edge: minEdge,
                        mst: [...mst],
                        visited: Array.from(visited)
                    });
                }
                return steps;
            }

            async kruskal() {
                const steps = [];
                const mst = [];
                const sets = new DisjointSet(this.nodes.length);
                
                const sortedEdges = [...this.edges].sort((a, b) => a.weight - b.weight);
                
                for (const edge of sortedEdges) {
                    if (!sets.connected(edge.source.id, edge.target.id)) {
                        sets.union(edge.source.id, edge.target.id);
                        mst.push(edge);
                        
                        steps.push({
                            type: 'edge',
                            edge: edge,
                            mst: [...mst]
                        });
                    }
                }
                return steps;
            }

            async visualizeAlgorithm(algorithm, startNode = 0) {
                let steps;
                switch(algorithm) {
                    case 'bfs': steps = await this.bfs(startNode); break;
                    case 'dfs': steps = await this.dfs(startNode); break;
                    case 'dijkstra': steps = await this.dijkstra(startNode); break;
                    case 'prim': steps = await this.prim(startNode); break;
                    case 'kruskal': steps = await this.kruskal(); break;
                    default: throw new Error('Unknown algorithm');
                }

                this.currentSteps = steps;
                const delay = getDelay();
                const stepList = document.getElementById('stepList');
                stepList.innerHTML = '';
                
                this.showAlgorithmInfo(algorithm);
                
                const stats = {
                    nodesVisited: 0,
                    edgesExamined: 0,
                    totalWeight: 0
                };

                for (let i = 0; i < steps.length; i++) {
                    const step = steps[i];
                    this.visualizeStep(step, i, algorithm);
                    this.updateStats(step, stats);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            visualizeStep(step, index, algorithm) {
                this.svg.selectAll('.node circle')
                    .attr('fill', d => {
                        if (step.type === 'visit' && d.id === step.node) return '#e74c3c';
                        else if (step.visited && step.visited.includes(d.id)) return '#2ecc71';
                        return '#3498db';
                    });

                this.svg.selectAll('.edge line')
                    .attr('stroke', d => {
                        if (step.type === 'discover' && 
                            d.source.id === step.from && 
                            d.target.id === step.node) return '#e74c3c';
                        return '#95a5a6';
                    })
                    .attr('stroke-width', d => {
                        if (step.type === 'discover' && 
                            d.source.id === step.from && 
                            d.target.id === step.node) return 3;
                        return 2;
                    });

                if (algorithm === 'dijkstra' && step.distances) {
                    this.svg.selectAll('.node-distance-label').remove();
                    this.svg.selectAll('.node')
                        .each(function(d) {
                            const distance = step.distances[d.id];
                            if (distance !== undefined) {
                                d3.select(this)
                                    .append('text')
                                    .attr('class', 'node-distance-label')
                                    .attr('x', 25)
                                    .attr('y', -25)
                                    .text(distance === Infinity ? '‚àû' : distance)
                                    .attr('font-size', '12px')
                                    .attr('fill', '#2c3e50');
                            }
                        });
                }

                if ((algorithm === 'prim' || algorithm === 'kruskal') && step.mst) {
                    this.svg.selectAll('.edge line')
                        .attr('class', d => 
                            step.mst.some(e => 
                                (e.source.id === d.source.id && e.target.id === d.target.id) ||
                                (e.source.id === d.target.id && e.target.id === d.source.id)
                            ) ? 'path-highlight' : ''
                        );
                }

                const stepItem = document.createElement('div');
                stepItem.className = 'step-item active';
                
                let description = '';
                if (step.type === 'visit') {
                    description = `Visiting node ${step.node}`;
                    if (step.distances) {
                        description += `<br>Distances: ${Object.entries(step.distances)
                            .map(([node, dist]) => `Node ${node}: ${dist === Infinity ? '‚àû' : dist}`)
                            .join(', ')}`;
                    }
                } else if (step.type === 'discover') {
                    description = `Discovered node ${step.node} from ${step.from}`;
                } else if (step.type === 'update') {
                    description = `Updated distance to node ${step.node}: ${step.distance}`;
                } else if (step.type === 'edge') {
                    description = `Added edge ${step.edge.source.id}-${step.edge.target.id} (weight: ${step.edge.weight})`;
                    if (step.mst) {
                        description += `<br>Current MST weight: ${step.mst.reduce((sum, e) => sum + e.weight, 0)}`;
                    }
                }

                stepItem.innerHTML = `
                    <div class="step-number">Step ${index + 1}</div>
                    <div class="step-description">${description}</div>
                    <div class="button-group">
                        <button class="btn mini-button" onclick="replayStep(${index})">Replay</button>
                        <button class="btn mini-button" onclick="showDetails(${index})">Details</button>
                    </div>
                `;
                
                document.getElementById('stepList').appendChild(stepItem);
                stepItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                const previousSteps = document.getElementsByClassName('active');
                Array.from(previousSteps).forEach(s => {
                    if (s !== stepItem) s.classList.remove('active');
                });
            }

            showAlgorithmInfo(algorithm) {
                const infoPanel = document.createElement('div');
                infoPanel.className = 'algorithm-info';
                
                const info = {
                    bfs: {
                        title: 'Breadth-First Search',
                        description: 'Explores all neighbor nodes at the present depth before moving to nodes at the next depth level.'
                    },
                    dfs: {
                        title: 'Depth-First Search',
                        description: 'Explores as far as possible along each branch before backtracking.'
                    },
                    dijkstra: {
                        title: 'Dijkstra\'s Algorithm',
                        description: 'Finds the shortest path between nodes in a graph.'
                    },
                    prim: {
                        title: 'Prim\'s Algorithm',
                        description: 'Finds a minimum spanning tree for a weighted undirected graph.'
                    },
                    kruskal: {
                        title: 'Kruskal\'s Algorithm',
                        description: 'Finds a minimum spanning forest of an undirected edge-weighted graph.'
                    }
                };

                infoPanel.innerHTML = `
                    <h3>${info[algorithm].title}</h3>
                    <p>${info[algorithm].description}</p>
                `;
                
                document.getElementById('stepPanel').prepend(infoPanel);
            }

            updateStats(step, stats) {
                if (step.type === 'visit') stats.nodesVisited++;
                if (step.type === 'edge') {
                    stats.edgesExamined++;
                    if (step.mst) {
                        stats.totalWeight = step.mst.reduce((sum, edge) => sum + edge.weight, 0);
                    }
                }
                
                const statsPanel = document.querySelector('.stats-panel') || 
                    (() => {
                        const panel = document.createElement('div');
                        panel.className = 'stats-panel';
                        document.getElementById('stepPanel').appendChild(panel);
                        return panel;
                    })();
                
                statsPanel.innerHTML = `
                    <div class="stats-item">
                        <span>Nodes Visited:</span>
                        <span>${stats.nodesVisited}</span>
                    </div>
                    <div class="stats-item">
                        <span>Edges Examined:</span>
                        <span>${stats.edgesExamined}</span>
                    </div>
                    ${step.mst ? `
                    <div class="stats-item">
                        <span>Total MST Weight:</span>
                        <span>${stats.totalWeight}</span>
                    </div>
                    ` : ''}
                `;
            }
        }

        const graphVisualizer = new GraphVisualizer('graphContainer');

        function addNode() {
            graphVisualizer.addNode();
        }

        function connectNodes() {
            document.getElementById('nodeModal').style.display = 'flex';
        }

        function confirmNodeConnection() {
            const source = parseInt(document.getElementById('sourceNode').value);
            const target = parseInt(document.getElementById('targetNode').value);
            const weight = parseInt(document.getElementById('edgeWeight').value) || 1;

            try {
                graphVisualizer.addEdge(source, target, weight);
                closeModal();
            } catch (error) {
                alert(error.message);
            }
        }

        function closeModal() {
            document.getElementById('nodeModal').style.display = 'none';
            document.getElementById('sourceNode').value = '';
            document.getElementById('targetNode').value = '';
            document.getElementById('edgeWeight').value = '';
        }

        function resetGraph() {
            graphVisualizer.resetGraph();
        }

        async function runAlgorithm() {
            const algorithm = document.getElementById('algorithmSelect').value;
            try {
                await graphVisualizer.visualizeAlgorithm(algorithm);
            } catch (error) {
                alert('Error running algorithm: ' + error.message);
            }
        }

        function replayStep(stepIndex) {
            if (graphVisualizer.currentSteps[stepIndex]) {
                const step = graphVisualizer.currentSteps[stepIndex];
                const algorithm = document.getElementById('algorithmSelect').value;
                graphVisualizer.visualizeStep(step, stepIndex, algorithm);
                
                const steps = document.getElementsByClassName('step-item');
                Array.from(steps).forEach((s, i) => {
                    s.classList.toggle('active', i === stepIndex);
                });
            }
        }

        function showDetails(stepIndex) {
            if (graphVisualizer.currentSteps[stepIndex]) {
                const step = graphVisualizer.currentSteps[stepIndex];
                let details = `Step ${stepIndex + 1} Details:\n`;
                details += `Type: ${step.type}\n`;
                
                if (step.node !== undefined) details += `Node: ${step.node}\n`;
                if (step.from !== undefined) details += `From: ${step.from}\n`;
                if (step.distance) details += `Distance: ${step.distance}\n`;
                if (step.edge) details += `Edge: ${step.edge.source.id}-${step.edge.target.id} (weight: ${step.edge.weight})\n`;
                
                alert(details);
            }
        }

        function generateRandomGraph() {
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            const density = parseInt(document.getElementById('density').value) / 100;
            const maxWeight = parseInt(document.getElementById('maxWeight').value);

            if (nodeCount < 2 || nodeCount > 15) {
                alert('Node count must be between 2 and 15');
                return;
            }
            if (maxWeight < 1 || maxWeight > 100) {
                alert('Max weight must be between 1 and 100');
                return;
            }

            graphVisualizer.resetGraph();

            const padding = 100;
            const width = graphVisualizer.width - 2 * padding;
            const height = graphVisualizer.height - 2 * padding;
            const angleStep = (2 * Math.PI) / nodeCount;

            for (let i = 0; i < nodeCount; i++) {
                const angle = i * angleStep;
                const radius = Math.min(width, height) / 3;
                const node = {
                    id: i,
                    x: graphVisualizer.width / 2 + radius * Math.cos(angle),
                    y: graphVisualizer.height / 2 + radius * Math.sin(angle)
                };
                graphVisualizer.nodes.push(node);
            }

            const maxEdges = (nodeCount * (nodeCount - 1)) / 2;
            const targetEdges = Math.floor(maxEdges * density);
            const addedEdges = new Set();

            for (let i = 1; i < nodeCount; i++) {
                const source = i - 1;
                const target = i;
                const weight = Math.floor(Math.random() * maxWeight) + 1;
                graphVisualizer.addEdge(source, target, weight);
                addedEdges.add(`${source}-${target}`);
            }

            while (addedEdges.size < targetEdges) {
                const source = Math.floor(Math.random() * nodeCount);
                const target = Math.floor(Math.random() * nodeCount);
                const edgeKey = `${Math.min(source, target)}-${Math.max(source, target)}`;

                if (source !== target && !addedEdges.has(edgeKey)) {
                    const weight = Math.floor(Math.random() * maxWeight) + 1;
                    try {
                        graphVisualizer.addEdge(source, target, weight);
                        addedEdges.add(edgeKey);
                    } catch (error) {
                        console.error('Error adding edge:', error);
                    }
                }
            }

            graphVisualizer.simulation.alpha(1).restart();
        }

        const resizeHandler = () => {
            graphVisualizer.width = graphVisualizer.container.clientWidth;
            graphVisualizer.height = graphVisualizer.container.clientHeight;
            graphVisualizer.simulation.force('center', 
                d3.forceCenter(graphVisualizer.width / 2, graphVisualizer.height / 2));
            graphVisualizer.simulation.alpha(1).restart();
            
            graphVisualizer.svg.selectAll('.node-distance-label')
                .attr('x', 25)
                .attr('y', -25);
        };

        const keydownHandler = (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                switch(e.key.toLowerCase()) {
                    case 'n': addNode(); break;
                    case 'c': connectNodes(); break;
                    case 'r': resetGraph(); break;
                    case ' ': runAlgorithm(); break;
                    case 'g': generateRandomGraph(); break;
                }
            }
        };

        window.addEventListener('resize', resizeHandler);
        document.addEventListener('keydown', keydownHandler);

        window.addEventListener('unload', () => {
            window.removeEventListener('resize', resizeHandler);
            document.removeEventListener('keydown', keydownHandler);
        });

        document.getElementById('density').addEventListener('input', function() {
            document.getElementById('densityValue').textContent = this.value + '%';
        });

        const speedControl = document.getElementById('speedControl');
        speedControl.addEventListener('input', function() {
            const speeds = ['Very Slow', 'Slow', 'Normal', 'Fast', 'Very Fast'];
            document.getElementById('speedLabel').textContent = speeds[this.value - 1];
        });

        function getDelay() {
            const delays = [1000, 800, 600, 400, 200];
            return delays[speedControl.value - 1];
        }

        document.addEventListener('DOMContentLoaded', () => {
            const speeds = ['Very Slow', 'Slow', 'Normal', 'Fast', 'Very Fast'];
            document.getElementById('speedLabel').textContent = speeds[speedControl.value - 1];
        });
    </script>
</body>
</html>